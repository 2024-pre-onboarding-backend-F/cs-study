## 2주차 주제 : 알고리즘

### 🎨 공통 질문 

1. **동적 계획법(DP, Dynamic Programming)에 대해 설명해주세요.**

<details>
  <summary>김영주</summary>
  <!-- 내용 -->
</details>

<details>
  <summary>이지원</summary>
  
  동적 계획법이란 주어진 문제를 풀기 위해 문제를 여러 개의 하위 문제로 나누어 푸는 방법을 의미합니다.

  어떤 부분 문제가 다른 문제들을 해결하는데 사용될 수 있어, 답을 여러 번 계산하는 대신 한 번만 계산하고 그 결과를 재활용하는 메모이제이션(Memoization)기법으로 속도를 향상시킬 수 있습니다.
</details>

<details>
  <summary>정은경</summary>
  <!-- 내용 -->
</details>

<details>
  <summary>정진희</summary>
  <!-- 내용 -->
</details>

</br>

2. **퀵 정렬(Quick Sort)에 대해 설명해주세요.**

<details>
  <summary>김영주</summary>
  <!-- 내용 -->
</details>

<details>
  <summary>이지원</summary>
  퀵 정렬은 빠른 정렬 속도를 자랑하는 분할 정복 알고리즘 중 하나로, 피봇을 설정하고 피봇보다 큰 값과 작은 값으로 분할하여 정렬하는 방법입니다.
</details>

<details>
  <summary>정은경</summary>
  <!-- 내용 -->
</details>

<details>
  <summary>정진희</summary>
  <!-- 내용 -->
</details>

</br>

3. **Big-O 표기법의 시간 복잡도 크기 순서를 말해주세요.**

<details>
  <summary>김영주</summary>
  <!-- 내용 -->
</details>

<details>
  <summary>이지원</summary>
  
  시간 복잡도는 알고리즘의 실행 속도를 의미합니다.

  Big-O 표기법의 시간 복잡도 크기 순서는 $O(1) < O(log N) < O(N) < O(NlogN) < O(N^2) < O(2^N) < O(N!)$입니다.
</details>

<details>
  <summary>정은경</summary>
  <!-- 내용 -->
</details>

<details>
  <summary>정진희</summary>
  <!-- 내용 -->
</details>

</br>

4. **재귀 알고리즘에 대해 설명해주세요.**

<details>
  <summary>김영주</summary>
  <!-- 내용 -->
</details>

<details>
  <summary>이지원</summary>

  재귀 알고리즘은 함수 내부에서 함수가 자기 자신을 또 다시 호출하여 문제를 해결하는 알고리즘을 말합니다.

  재귀 알고리즘의 경우 무한루프에 빠지지 않도록 종료 조건을 명확하게 설정해주어야 합니다.
</details>

<details>
  <summary>정은경</summary>
  <!-- 내용 -->
</details>

<details>
  <summary>정진희</summary>
  <!-- 내용 -->
</details>

</br>

5. **선택 정렬(Selection Sort)에 대해 설명해주세요.**

<details>
  <summary>김영주</summary>
  <!-- 내용 -->
</details>

<details>
  <summary>이지원</summary>

  선택 정렬은 가장 작은 데이터를 찾아 가장 앞의 데이터와 교환해나가는 방식으로, 시간 복잡도는 $O(N^2)$입니다.
</details>

<details>
  <summary>정은경</summary>
  <!-- 내용 -->
</details>

<details>
  <summary>정진희</summary>
  <!-- 내용 -->
</details>

</br>

6. **삽입 정렬(Injection Sort)에 대해 설명해주세요.**

<details>
  <summary>김영주</summary>
  <!-- 내용 -->
</details>

<details>
  <summary>이지원</summary>

  삽입 정렬은 두 번째 값부터 시작해 그 앞에 존재하는 원소들과 비교하여 위치를 지정하는 방식입니다.

  최선의 경우 시간 복잡도는 $O(N)$이고, 평균, 최악의 경우 시간 복잡도는 $O(N^2)$입니다.
</details>

<details>
  <summary>정은경</summary>
  <!-- 내용 -->
</details>

<details>
  <summary>정진희</summary>
  <!-- 내용 -->
</details>

</br>

7. **병합 정렬(Merge Sort)에 대해 설명해주세요.**

<details>
  <summary>김영주</summary>
  <!-- 내용 -->
</details>

<details>
  <summary>이지원</summary>

  병합 정렬은 하나의 리스트를 두 개의 리스트로 분할한 다음 각각의 분할된 리스트를 정렬한 후에 합해서 정렬된 하나의 리스트로 만드는 정렬 알고리즘입니다.

  시간 복잡도는 $O(NlogN)$입니다.
</details>

<details>
  <summary>정은경</summary>
  <!-- 내용 -->
</details>

<details>
  <summary>정진희</summary>
  <!-- 내용 -->
</details>

</br>

8. **허프만 코딩에 대해 설명해주세요.**

<details>
  <summary>김영주</summary>
  <!-- 내용 -->
</details>

<details>
  <summary>이지원</summary>

  허프만 코딩은 데이터 문자의 빈도 수를 가지고 압축하는 과정을 의미합니다.

  주로 접두부 코드와 최적 코드를 사용합니다. 이때 접두부 코드란, 각 문자에 부여된 이진 코드가 다른 이진 코드의 접두부가 되지 않는 코드를 의미합니다.
</details>

<details>
  <summary>정은경</summary>
  <!-- 내용 -->
</details>

<details>
  <summary>정진희</summary>
  <!-- 내용 -->
</details>

</br>

### 💡 추가로 공부해 온 내용



</br>

### 💫 공부한 내용 정리한 링크
| 이름 | 블로그 링크 |
|------|--------------|
|김영주||
|이지원|<a href="algorithm_jiwon.md" target="_blank">github md파일</a>||
|정은경|<a href="https://velog.io/@jeg1124/series/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98" target="_blank">블로그 링크</a>|
|정진희||
