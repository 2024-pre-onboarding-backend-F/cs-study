## 2주차 주제 : 자료구조

### 🎨 공통 질문 

1. **Array와 LinkedList의 차이점**

<details>
  <summary>김영주</summary>
  <!-- 내용 -->
</details>

<details>
  <summary>이지원</summary>
  
  Array는 순차적으로 데이터를 저장하는 자료구조로, 크기는 처음 생성할 때 정해지며 이후 변경이 불가능합니다. 또한, 검색이 빠르지만 삽입과 삭제가 느리다는 특징이 있습니다.

  LinkedList는 데이터를 저장하고 있는 각 노드를 서로 연결 시켜 만든 선형 자료구조로, 크기가 정해져 있지 않습니다. 또한, 삽입과 삭제는 빠르지만 검색이 느리다는 특징이 있습니다.
</details>

<details>
  <summary>정은경</summary>
  배열(Array)는 빠른 접근이 요구되고, 데이터의 삽입과 삭제가 적을 때 사용됩니다. 배열의 크기는 처음 생성할 때 정해지며 이후 변경할 수 없습니다. 인덱스를 통한 빠른 접근이 가능하다는 장점이 있습니다. 다만, 삽입/삭제가 오래 걸리고 배열 중간에 있는 데이터가 삭제되면 공간 낭비가 발생한다는 단점이 있습니다.

  연결리스트(LinkedList)는 삽입과 삭제가 많고, 데이터 검색 빈도가 적을 때 사용됩니다. 항목들이 노드로 연결되어 있습니다. 삽입과 삭제가 용이하다는 장점이 있습니다. 다만, 임의 접근이 불가능하기에 처음부터 탐색을 진행해야 합니다.  
</details>

<details>
  <summary>정진희</summary>
  
  > Array는 연속된 메모리 공간에 데이터가 저장되며, **인덱스**를 사용해 데이터에 빠르게 접근할 수 있습니다. </br> 하지만 크기가 고정되어 있고, 중간에 요소를 삽입/삭제할 때는 많은 데이터 이동이 필요해 비효율적입니다.

> LinkedList는 메모리가 불연속적으로 할당되며, 각 요소가 다음 요소의 주소를 포함하는 **노드 형태로 연결**되어 있습니다. </br> 삽입/삭제가 빠르지만, 특정 인덱스의 데이터에 접근하려면 처음부터 순차적으로 탐색해야 하므로 데이터 접근 속도는 느립니다.
</details>

</br>

2. **Stack과 Queue의 개념 및 사용 사례**

<details>
  <summary>김영주</summary>
  <!-- 내용 -->
</details>

<details>
  <summary>이지원</summary>

  Stack은 먼저 들어간 요소가 가장 나중에 나오게 되는 선입후출(LIFO, Last In First Out)의 구조를 가진 선형 자료구조로, 브라우저의 '뒤로가기'와 ctrl + z 되돌리기 연산 등에 사용됩니다.

  Queue는 먼저 들어간 요소가 가장 먼저 나오게 되는 선입선출(FIFO, First In First Out)의 구조를 가진 선형 자료구조로, 프린터 출력 요청, CPU 스케줄링 Ready 큐 등에 사용됩니다.
</details>

<details>
  <summary>정은경</summary>
  스택(Stack)은 먼저 들어온 데이터가 나중에 나가는 후입선출(LIFO)의 구조를 가진 자료구조입니다. 함수 호출 시 복귀 주소, 이전페이지 들에 사용됩니다.

  큐(Queue)는 먼저 들어온 데이터가 가장 먼저 나가는 선입선출(FIFO)의 구조를 가진 자료구조입니다. 시뮬레이션의 대기열, 컴퓨터시스템의 버퍼링 등에 사용됩니다.
</details>

<details>
  <summary>정진희</summary>
  
  > Stack은 **후입선출(LIFO, Last-In-First-Out)** 구조로, 가장 마지막에 들어온 데이터가 먼저 나갑니다. </br> 사용 사례로 함수 호출 시의 메서드 스택, 브라우저의 뒤로 가기, 실행 취소(undo) 기능 등이 있습니다.

> Queue는 **선입선출(FIFO, First-In-First-Out)** 구조로, 먼저 들어온 데이터가 먼저 나갑니다. </br> 사용 사례로 작업 대기열, 프린터 작업 처리, 네트워크 패킷 전송 등이 있습니다.
</details>

</br>

3. **Priority Queue 및 Heap**

<details>
  <summary>김영주</summary>
  <!-- 내용 -->
</details>

<details>
  <summary>이지원</summary>
  
  Priority Queue는 우선순위 큐로, 들어간 순서에 상관없이 우선순위가 높은 데이터를 먼저 꺼내기 위해 고안된 자료구조입니다.

  우선순위 큐는 주로 Array, LinkedList, Heap을 사용해 구현되는데, 시간복잡도 때문에 주로 Heap을 사용하는 방식으로 구현됩니다.

  Heap은 최댓값 또는 최솟값을 찾아내는 연산을 쉽게 하기 위해 고안된 구조로, 완전이진트리입니다. 힙은 최대힙(각 노드의 키값이 자식의 키값보다 작지 않은 자료구조)과 최소힙(각 노드의 키값이 자식의 키값보다 크지 않은 자료구조)이 있습니다.
</details>

<details>
  <summary>정은경</summary>
  우선순위 큐는 가장 우선순위가 높은 데이터를 먼저 사용하는 자료구조입니다. 주로 힙 트리를 이용하여 구현됩니다.

  힙은 완전 이진 트리 형식으로 종류에는 최대 힙과 최소 힙이 있습니다. 힙은 완전이진트리이기에 일반적으로 노드 객체 배열을 이용하여 구현합니다. 
  최대 힙은 부모 노드의 키 값이 자식 노드보다 큰 완전 이진 트리, 최소 힙은 부모 노드의 키 값이 자식 노드보다 작은 완전 이진 트리입니다.
</details>

<details>
  <summary>정진희</summary>
  
  > 우선순위 큐는 데이터가 **우선순위에 따라 정렬**되며, 가장 높은 우선순위를 가진 요소가 먼저 나갑니다. </br> 일반 Queue와 달리 우선순위가 있는 작업을 먼저 처리하는 데 사용됩니다.

> Heap은 우선순위 큐를 구현하기 위한 데이터 구조로, 이진 트리 형태로 구성되며 최대 힙(max-heap)과 최소 힙(min-heap)으로 나뉩니다. </br> 최대 힙은 부모 노드가 자식 노드보다 크거나 같고, 최소 힙은 부모 노드가 자식 노드보다 작거나 같습니다.
</details>

</br>

4. **Hash Table과 Hash Collision 해결 방법**

<details>
  <summary>김영주</summary>
  <!-- 내용 -->
</details>

<details>
  <summary>이지원</summary>

  Hash Table은 (Key, Value)로 데이터를 저장하는 자료구조로, 빠르게 데이터를 검색할 수 있는 자료구조를 의미합니다. 빠른 검색 속도를 제공하는 이유는 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문입니다.

  각 Key값은 해시함수에 의해 고유한 index를 가지게 되어 바로 접근할 수 있으므로 평균 $O(1)$의 시간 복잡도로 데이터를 조회할 수 있습니다.

  Hash Collision은 서로 다른 Key에 대해 같은 해시값을 갖는 경우 발생하는데, 해시 테이블에 접근하는 Key 값은 무한하지만 해시 함수를 통해 나온 Hash 값은 유한하기 때문입니다.

  Hash Collision을 해결하는 방법에는 크게 Separate Chaining(분리 연결법)과 Open Addressing(개방 주소법)이 있습니다.
</details>

<details>
  <summary>정은경</summary>
  해시 테이블(Hash Table)은 Key-Value 형태로 저장되는 자료구조로, key 값을 해시함수를 이용해 해시 테이블에 저장할 위치를 정합니다. 이때 내부적으로 버킷을 사용해 저장합니다.

  해시충돌은 다른 키 값일 때, 해시 함수를 통해 같은 값을 가지게 되는 경우 발생합니다. 즉, 어떤 객체를 넣으려고 할 때 해시함수로 찾은 위치에 이미 다른 객체가 존재하는 경우 발생합니다.
  이러한 해시충돌을 해결하기 위해서는 체이닝(같은 주소로 해싱될 때 연결리스트로 연결하는 방식), 개방주소법(추가 공간을 활용하지 않고 충돌을 해결)이 있습니다.
</details>

<details>
  <summary>정진희</summary>

  > 해시 테이블은 Key-Value 쌍으로 저장하며, 키를 해시 함수에 입력하여 고유한 해시 값을 생성하고 이를 통해 데이터를 저장합니다.
> </br> 평균적으로 검색 시간 복잡도는 Θ(1) 입니다.

> 해시 테이블에 접근하는 Key 값은 무한하고, 해시 함수를 통해 나온 해시 값은 유한하기 때문에 서로 다른 Key에 대해 같은 해시 값을 갖는 경우를 해시 충돌이라고 합니다. </br> 
해결 방법으로 인덱스의 버킷을 연결리스트로 구현해, 이미 값이 존재하더라도 연결리스트에 해당 값을 삽입하는 방식인 <b>체이닝(Chaining)</b>과 충돌이 발생하면 특정한 간격만큼 이동 후 다른 빈 버킷을 찾아 데이터를 저장하는 **개방 주소법(Open Addressing)** 방식이 있습니다.

</details>

</br>

5. **BST (Binary Search Tree)와 성능 개선 방법에 대해 설명해주세요.**

<details>
  <summary>김영주</summary>
  <!-- 내용 -->
</details>

<details>
  <summary>이지원</summary>

  BST는 이진 탐색 트리로, 이진 탐색과 연결 리스트를 결합한 자료구조입니다. 왼쪽 트리의 모든 값은 반드시 부모 노드보다 작아야 하고, 오른쪽 트리의 값은 부모 노드보다 커야 하는 특징이 있습니다.

  BST의 탐색 연산은 트리의 높이에 영향을 받기 때문에 높이가 h일 때 시간 복잡도는 $O(h)$입니다. 그러나 트리의 균형이 한쪽으로 치우쳐진 경우 worst case가 되고 $O(N)$의 시간 복잡도를 가지게 됩니다.

  BST의 성능 개선 방법에는 BST의 양쪽 높이의 균형을 맞추는 방법이 있는데, 이 방법으로 BST를 개량한 AVL 트리와 Red-Black 트리가 있습니다.

  RBT(Red-Black Tree)는 BST를 기반으로 하는 트리 형식 자료구조로, BST의 삽입, 삭제 연산 과정에서 발생할 수 있는 문제점을 해결하기 위해 만들어졌습니다. 모든 노드는 빨간색 또는 검은색이고, 루트 노드는 검은색, 모든 리프 노드들은 검은색, 빨간색 노드의 자식은 검은색으로, 빨간색 노드가 연속으로 나올 수 없다는 특징을 가집니다.
</details>

<details>
  <summary>정은경</summary>
  이진 탐색 트리(BST)는 탐색을 효율적으로 하기 위한 자료구조로, 왼쪽서브 트리의 키 값은 루트 노드의 키 값보다 작아야 하고, 오른썩 서브트리 노드의 키값은 루트 노드의 키 값보다 커야 합니다.

  이진 탐색 트리는 노드가 편향되거나 데이터가 균형 잡히지 않으면 성능 문제가 발생합니다. 
  첫째, 트리 균형을 유지하기 위해 AVL 트리나 레드-블랙 트리와 같은 자체 균형 트리를 활용합니다.
  둘째, 데이터 삽입 순서로 인해 트리가 편향될 위험이 있는 경우 랜덤화 삽입을 활용합니다.

  > 레드-블랙 트리: 삽입 및 삭제 시 트리의 균형을 유지하기 위해 색상 속성을 사용하는 균형 이진 탐색 트리이다. 균형은 AVL보다 덜 엄격하지만 연산 속도가 더 빠르다
  > B-트리/B+트리 : 데이터베이스나 파일 시스템에서 사용되며, 노드에 여러 키를 저장하고 균형 상태 유지 
</details>

<details>
  <summary>정진희</summary>
  
  > 이진 탐색 트리에서 부모 노드의 key 값은 왼쪽 자식 노드보다 크고, 오른쪽 자식 노드보다 작아야 합니다. </br> 하위 트리도 이진 탐색 이어야 하며 중복된 key 값을 허용하지 않습니다.

  > BST의 성능을 개선하기 위해 균형 트리(AVL 트리, 레드-블랙 트리 등)를 사용하거나, 대용량 데이터를 처리할 경우 B-트리 계열을 사용하는 것이 일반적입니다.
</br> 이러한 트리들은 삽입과 삭제 시 균형을 유지하여 최악의 경우에도 O(log N)의 시간 복잡도를 유지함으로써 성능을 개선할 수 있습니다.
</details>

</br>

6. **AVL 트리는 무엇인가요?**

<details>
  <summary>김영주</summary>
  <!-- 내용 -->
</details>

<details>
  <summary>이지원</summary>

  BST를 기반으로 하는 트리 형식 자료구조로, 각 노드의 서브트리 높이 차이가 최대 1을 유지하도록 스스로 균형을 유지하는 트리를 의미합니다. 삽입과 삭제 연산을 수행할 때마다 트리의 균형 계수를 체크하고 균형 계수가 1보다 커질 때 회전(Rotation) 연산을 통해 균형을 유지한다는 특징을 가집니다.
</details>

<details>
  <summary>정은경</summary>
  AVL 트리는 스스로 균형을 잡는 이진 탐색 트리입니다. 왼쪽과 오른쪽 서브트리의 높이 차이가 최대 1을 유지하도록 회전을 통해 균형을 잡아 높이를 유지합니다.
  AVL 트리의 모든 노드는 BF(Balance Factor, 균형이 무너졌는지에 대한 판단)가 -1, 0, 1 중 하나여야 하며, 만약 이를 벗어나면 균형이 깨졌다는 것을 의미해 이때 회전이 필요합니다.

  > BF(K) = K의 왼쪽 서브트리의 높이 – K의 오른쪽 서브트리의 높이
</details>

<details>
  <summary>정진희</summary>
  
  > AVL 트리는 각 노드의 왼쪽 서브 트리와 오른쪽 서브 트리의 높이 차가 1 이하가 되도록 유지하는 트리입니다. </br>
삽입이나 삭제 시 트리의 균형이 깨지면 회전(Rotation) 연산을 통해 균형을 맞춥니다.
</details>

</br>

7. **트리와 그래프의 차이에 대해서 설명할 수 있나요?**

<details>
  <summary>김영주</summary>
  <!-- 내용 -->
</details>

<details>
  <summary>이지원</summary>

  그래프는 노드(하나의 점)와 노드 간을 연결하는 간선으로 구성된 자료 구조로, 방향이 있는 그래프와 방향이 없는 그래프가 모두 존재하고 루트 노드의 개념과 부모-자식 관계라는 개념이 없습니다.

  트리는 그래프와 같이 노드와 노드간을 연결하는 간선으로 구성된 자료구조로, 두 개의 노드 사이에 반드시 1개의 경로만 가지며, 사이클이 존재하지 않는 방향 그래프입니다. 그리고 부모-자식 관계가 성립하는 계층형 모델입니다.

  따라서 그래프는 트리보다 더 포괄적인 개념입니다.
</details>

<details>
  <summary>정은경</summary>
  트리는 계층적인 구조를 나타내는 비선형 자료구조입니다. 항상 방향성이 있으며, 노드는 부모에서 자식으로만 연결됩니다. 비순환 구조로만 이루어져 있고, 하나의 루트 노드가 존재하며 이를 중심으로 계층 구조를 형성합니다. 트리는 N개의 노드가 있다면 간선의 수는 항상 N-1개입니다. 

  그래프는 노드와 노드 간을 연결하는 간선으로 구성된 자료구조입니다. 방향 그래프와 무방향 그래프 모두 존재하고 순환/비순환/자기순환 등이 가능합니다. 로트 노드의 개념이 따로 업속, 부모-자식 관계가 없어 노드 간 연결만 존재합니다. 트리와 다르게 간선 수에 제한이 없습니다.
  
</details>

<details>
  <summary>정진희</summary>
  
  > 그래프는 **노드**라는 점과 노드를 연결해 주는 선인 **엣지**로 이루어진 자료구조입니다. </br>
트리는 그래프의 한 종류이며 **방향성이 있는 비순환 그래프**입니다. </br>
연결된 노드로 그래프는 개체 간의 "관계"를 표현한다면 트리는 개체를 "계층" 구조로 표현합니다. </br>
그래프는 부모-자식 관계라는 개념이 없고, 트리는 있으며 최상위에 Root 노드가 존재합니다.
</details>

</br>

8. **이진트리의 전위 / 중위 / 후위 순회가 무엇인가요? 설명해보세요**

<details>
  <summary>김영주</summary>
  <!-- 내용 -->
</details>

<details>
  <summary>이지원</summary>

  전위 순회는 Root - Left - Right 순서로 노드를 순회하는 것으로, 루트를 먼저 방문합니다.

  중위 순회는 Left - Root - Right 순서로 노드를 순회하는 것으로, 루트를 중간에 방문합니다.

  후위 순회는 Left - Right - Root 순서로 노드를 순회하는 것으로, 루트를 후에 방문합니다.
</details>

<details>
  <summary>정은경</summary>
  전위 순회는 루트 > 왼쪽 > 오른쪽 순서로 노드를 순회하는 방식입니다. 
  중위 순회는 왼쪽 > 루트 > 오른쪽 순서로 노드를 순회하는 방식입니다.
  후위 순회는 왼쪽 > 오른쪽 > 루트 순서로 노드를 순회하는 방식입니다.
</details>

<details>
  <summary>정진희</summary>
  
  > 이진 트리는 각 노드가 최대 2개의 자식 노드를 가집니다.
- 전위 순회는 [루트 - 왼쪽 자식 - 오른쪽 자식] 순으로 순회합니다.
- 중위 순회는 [왼쪽 자식 - 루트 - 오른쪽 자식] 순으로 순회합니다.
- 후위 순회는 [왼쪽 자식 - 오른쪽 자식 - 루트] 순으로 순회합니다.
</details>

</br>

### 💡 추가로 공부해 온 내용



</br>

### 💫 공부한 내용 정리한 링크
| 이름 | 블로그 링크 |
|------|--------------|
|김영주||
|이지원|<a href="data_structure_jiwon.md" target="_blank">github md파일</a>|
|정은경|<a href="https://velog.io/@jeg1124/series/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0" target="_blank">블로그 링크</a>|
|정진희|<a href="https://velog.io/@jjh0526/series/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EB%8C%80%EB%B9%84-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0" target="_blank">자료구조 블로그 링크</a>|
