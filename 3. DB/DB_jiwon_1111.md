# 3주차 첫번째 : 데이터베이스 (이지원)

### 🎨 공통 질문
<details>
<summary><strong>DB에서 사용하는 '키'에 대해 설명하고, 키의 종류에 대해 설명이 가능할까요?</strong></summary>
<div markdown="1">
<ul>
<div>

### 키(Key)

- 데이터베이스에서 각 **행**을 구분하는 **유일한 식별자**
- 일반적으로 테이블에서 하나 이상의 열로 구성되며 해당 열 값은 유일하고 불변해야 함

### 키 종류

**슈퍼키(Super Key)**

- **유일성**을 만족해야 하는 키

- 행을 고유하게 식별할 수 있는 모든 필드의 조합

**후보키(Candidate Key)**

- 기본키가 될 수 있는 후보로 선정된 키

- 슈퍼키 중에서 **최소성**을 만족하는 키

> 유일성 : 모든 레코드에서 해당 필드에 중복된 값이 나타나지 않는다는 속성
> 
> 최소성 : 최소한의 필드로 레코드를 유일하게 구별할 수 있어야 한다는 속성
> 

**기본키(Primary Key)**

- 테이블에서 각 행을 유일하게 식별할 수 있는 키

- 후보키들 중에서 하나를 선택한 키

- NULL 값, 중복값 허용 X

**대체키(Alternate Key)**

- 후보키 중에서 기본키로 지정하고 남은 후보키들

![image](https://github.com/user-attachments/assets/2977730c-c947-4a26-87cb-aac71319bf68)

**외래키(Foreign Key)**

- 한 테이블의 키 중에서 다른 테이블의 레코드를 유일하게 식별할 수 있는 키

- 하나의 테이블에서 다른 테이블의 기본키를 참조

</div>
</ul>
</div>
</details>
<details>
<summary><strong>트랜잭션이 무엇인지 설명하고, 트랜잭션의 특징에 대해 설명해주세요.</strong></summary>
<div markdown="1">
<ul>
<div>

### 트랜잭션(Transaction)

- 데이터베이스의 상태를 변화시키는 작업의 단위
- 작업의 일부만 적용되는 현상이 발생하지 않도록 작업의 완전성을 보장해줌

### 트랜잭션의 특징 (ACID)

- **원자성(Atomicity)** : 트랜잭션이 데이터베이스에 모두 반영되던가, 아니면 전혀 반영되지 않아야 한다는 것
- **일관성(Consistency)** : 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다는 것
- **독립성(Isolation)** : 둘 이상의 트랜잭션이 동시에 실행되고 있을 경우 어떤 하나의 트랜잭션이라도 다른 트랜잭션의 연산에 끼어들 수 없다는 것
- **영구성(Durability)** : 트랜잭션이 성공적으로 완료됐을 경우 결과는 영구적으로 반영되어야 한다는 것
</div>
</ul>
</div>
</details>
<details>
<summary><strong>트랜잭션의 격리수준과 동시성 문제 해결 방법에 대해 말해주세요.</strong></summary>
<div markdown="1">
<ul>
<div>

### **트랜잭션 격리수준**

- 동시에 여러 트랜잭션이 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 여부를 결정하는 것

![image](https://github.com/user-attachments/assets/b5d4e90d-aa92-40be-8340-4e7f40617f4b)


- **Serializable**
    - 여러 트랜잭션이 동일한 레코드에 동시에 접근 불가
    - 데이터 접근 시 항상 Lock 걸고 데이터 조회
    - 순차적으로 처리도어야 하기 때문에 동시 처리 성능 매우 떨어짐
- **Repeatable Read**
    - 커밋이 완료된 데이터만 읽을 수 있으며, 트랜잭션 범위 내에서 조회한 내용이 항상 동일함을 보장
    - 다른 트랜잭션에서 수행한 변경 작업에 의해 다른 트랜잭션에 의해 추가된 레코드가 발견되는 **Phantom Read** 현상
- **Read Committed**
    - 커밋된 데이터만 조회 가능
    - 반복 읽기를 수행하면 다른 트랜잭션의 커밋 여부에 따라 조회 결과가 달라지는 Nonrepeatable Read(반복 읽기 불가능) 현상 발생
- **Read Uncommitted**
    - 커밋되지 않은 데이터도 접근 가능

### 동시성 문제

- 데이터베이스에 두 명 이상의 유저가 동시에 접근할 때 발생할 수 있는 문제
- 동시에 여러 개의 트랜잭션이 수행될 때, 트랜잭션들이 DB의 일관성을 파괴하지 않도록 트랜잭션 간의 상호작용을 제어하는 **동시성 제어**가 중요

### 동시성 문제 해결 방법

- **Locking** : 트랜잭션들이 동일한 데이터 항목에 대해 임의적인 병행 접근을 하지 못하도록 제어하는 것
- **2 Phase Locking** : 락을 걸고 해제하는 시점에 제한을 두지 않으면 두 개의 트랜잭션이 동시에 실행될 때 데이터의 일관성이 깨질 수 있어서 로킹 단계를 확장과 수축 단계로 구분하여 이를 방지하는 방법
- **Timestamp Ordering** : 트랜잭션을 식별하기 위하여 DBMS가 부여하는 유일한 식별자인 타임 스탬프를 지정하여 트랜잭션간의 순서를 미리 선택하는 동시성 제어 기법
- **낙관적 검증** : 트랜잭션 수행 동안은 어떠한 검사도 하지 않고, 트랜잭션 종료 시에 일괄적으로 검사하는 기법
- **MVCC(다중버전 동시성 제어)** : 트랜잭션이 한 데이터 아이템을 접근하려 할 때, 그 트랜잭션의 타임스탬프와 접근하려는 데이터 아이템의 여러 버전의 타임스탬프를 비교하여, 현재 실행하고 있는 스케줄의 직렬가능성이 보장되는 적절한 버전을 선택하여 접근하도록 하는 기법

### ➕ Lock이란?

- 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 하나의 커넥션만 변경할 수 있게 해주는 기능
- 동시성을 제어하기 위한 기능
- 종류
    - 공유 Lock (Shared Lock, Read Lock) : 데이터를 변경하지 않는 읽기 작업을 위해 잠그는 것
    - 베타 Lock (Exclusive Lock, Write Lock) : 데이터를 변경하는 작업을 위해 잠그는 것
</div>
</ul>
</div>
</details>
<details>
<summary><strong>정규화와 역정규화에 대해 설명해주세요.</strong></summary>
<div markdown="1">
<ul>
<div>

### 정규화

- 하나의 릴레이션에 하나의 의미만 존재하도록 릴레이션을 분해하는 과정
    - 릴레이션 : 데이터들을 표의 형태로 표현한 것
- 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법

### 정규화 목적

1. 불필요한 데이터 제거해 불필요한 중복 최소화
2. 삽입/갱신/삭제 시 발생할 수 있는 각종 이상 현상 방지 위해
    - 이상 현상 : 테이블을 잘못 설계하여 데이터를 삽입, 삭제, 수정할 때 생기는 논리적 오류

### 정규화 종류

- **제1 정규화** : 테이블의 칼럼이 원자 값(Atomic Value, 하나의 값)을 갖도록 테이블을 분해하는 것
- **제2 정규화** : 제1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해하는 것
    - 완전 함수 종속 : 기본키의 부분집합이 결정자가 되어선 안된다는 것
- **제3 정규화** : 제2 정규화를 진행한 테이블에 대해 이행적 함수 종속을 없애도록 테이블을 분해하는 것
    - 이행적 함수 종속 : A → B , B → C가 성립할 때 A → C가 성립되는 것
- **BCNF 정규화** : 제3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것

### 정규화 장단점

- 장점
    - 데이터베이스 변경 시 이상현상이 발생하는 문제점 해결
    - 데이터베이스 구조 확장 시 정규화된 데이터베이스는 그 구조를 변경하지 않아도 되거나 일부만 변경해도 됨
- 단점
    - 릴레이션의 분해로 인해 릴레이션 간의 연산(JOIN 연산)이 많아짐 → 이로 인해 질의에 대한 응답 시간이 느려질 수 있음

### 역정규화

- 정규화한 표를 성능이나 편의성을 위해 되돌아가는 작업
- 정규화를 거치면 릴레이션 간의 연산(JOIN 연산)이 많아지는데, 이로인해 성능 저하의 우려가 있음 → 성능 문제가 있는(읽기 작업이 많이 필요한) DB의 전반적인 성능을 향상시키기 위해 역정규화 진행
</div>
</ul>
</div>
</details>
<details>
<summary><strong>RDB와 NoSQL의 차이에 대해서 설명하실 수 있나요?</strong></summary>
<div markdown="1">
<ul>
<div>

### **RDB(관계형 데이터베이스)**

- 정해진 스키마에 따라 데이터를 '테이블'에 저장하는 데이터베이스
- 데이터 구조가 보장되어있고, 중복을 피할 수 있음
- SQL을 사용해 RDBMS에서 데이터를 저장, 수정, 삭제 및 검색 가능
- 데이터 구조가 명확하고 변경될 여지가 없으며 스키마가 중요한 경우 주로 사용

### NoSQL

- 스키마가 없거나, 느슨한 스키마로 데이터 간의 관계 없이 자유로운 형태로 데이터를 저장하는 데이터베이스
- 유연하기 때문에 데이터 조정과 새로운 필드 생성이 자유로움
    - 스키마 없이 Key-Value 형태로 자유롭게 데이터 관리
- 중복을 계속해서 업데이트 해줘야 하는 단점
- 정확한 데이터 구조를 알 수 없고 데이터가 변경/확장 될 수 있는 경우 주로 사용
</div>
</ul>
</div>
</details>
<br>

### 💡 추가로 공부해 온 내용
<details>
<summary><strong>트리거가 무엇인지 설명해주세요.</strong></summary>
<div markdown="1">
<ul>
<div>

### 트리거

- 특정 테이블에 대한 이벤트에 반응해 INSERT, DELETE, UPDATE 같은 DML 문이 수행되었을 때, 데이터베이스에서 자동으로 동작하도록 작성된 프로그램
- 사용자가 직접 호출하는 것이 아닌, 데이터베이스에서 자동적으로 호출한다는 특징

### 트리거 목적

- 특정 테이블에 대한 데이터 변경을 시작점으로 설정하고, 그와 관련된 작업을 자동적으로 수행하기 위해
- 일반적으로 이벤트와 관련된 테이블의 데이터 삽입, 추가, 삭제 작업을 DBMS가 자동적으로 실행시키는데 활용하기 위해

### 종류

- 행 트리거 : 데이터 변화가 생길 때마다 실행
- 문장 트리거 : 트리거에 의해 단 한 번 실행
</div>
</ul>
</div>
</details>
<details>
<summary><strong>DML, DDL, DCL이 각각 무엇인지 설명해주세요.</strong></summary>
<div markdown="1">
<ul>
<div>

### DML(Data Manipulation Language, 조작어)

- 데이터베이스 내의 자료 검색, 삽입, 갱신, 삭제를 위한 언어
- SELECT, INSERT, UPDATE, DELETE

### DDL(Data Definition Language, 정의어)

- 데이터베이스 구조를 정의, 수정, 삭제하는 언어
- ALTER, CREATE, DROP

### DCL(Data Control Language, 제어어)

- 데이터에 대해 무결성 유지, 병행 수행 제어, 보호와 관리를 위한 언어
- COMMIT, ROLLBACK, GRANT, REVOKE
</div>
</ul>
</div>
</details>
<details>
<summary><strong>ORM이 무엇인지 설명해주세요.</strong></summary>
<div markdown="1">
<ul>
<div>

### ORM(**Object Relational Mapping)**

- 객체 관계 매핑
- 객체 지향 프로그래밍 언어와 관계형 데이터베이스 간의 데이터 변환을 자동화하기 위한 기술
- SQL 문법 대신 애플리케이션 개발 언어를 그대로 사용할 수 있게 함으로써 개발 언어의 일관성과 가독성을 높여준다는 장점
- 자바 ORM 기술에 대한 API 표준 명세가 JPA로, ORM을 사용하기 위한 인터페이스를 모아둔 것 → 이 JPA를 구현한 ORM 프레임워크가 Hibernate
</div>
</ul>
</div>
</details>
